#!/bin/bash
# OpenCode Toolbox - 带隔离的容器管理工具
# 默认使用 podman，默认挂载 git 配置

set -euo pipefail

TOOLBOX_IMAGE="${TOOLBOX_IMAGE:-localhost/opencode-toolbox:latest}"
CONTAINER_ENGINE="${CONTAINER_ENGINE:-podman}"
CONFIG_DIR="${HOME}/.config/opencode-toolbox"
CONFIG_FILE="${CONFIG_DIR}/config.yaml"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $*"; }
log_success() { echo -e "${GREEN}[OK]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }

# 生成有效的容器名称
# 输入: 项目名或路径
# 输出: 有效的容器名称部分
normalize_project_name() {
    local input="${1:-}"
    
    # 如果是空，使用当前目录名
    if [[ -z "$input" ]]; then
        input=$(basename "$(pwd)")
    fi
    
    # 如果是 . 或 ..，转换为目录名
    if [[ "$input" == "." ]]; then
        input=$(basename "$(pwd)")
    elif [[ "$input" == ".." ]]; then
        input=$(basename "$(cd .. && pwd)")
    fi
    
    # 如果是路径，提取最后一部分
    if [[ "$input" == */* ]]; then
        input=$(basename "$input")
    fi
    
    # 清理非法字符（只保留字母、数字、下划线、连字符）
    input=$(echo "$input" | tr -cd '[:alnum:]_-')
    
    # 转小写
    input=$(echo "$input" | tr '[:upper:]' '[:lower:]')
    
    # 如果为空，使用 default
    if [[ -z "$input" ]]; then
        input="default"
    fi
    
    echo "$input"
}

# 生成容器名称
generate_container_name() {
    local project_name="$1"
    echo "toolbox-opencode-${project_name}"
}

detect_engine() {
    if command -v podman &> /dev/null; then
        echo "podman"
    elif command -v docker &> /dev/null; then
        echo "docker"
    else
        echo "podman"
    fi
}

get_user_info() {
    export HOST_USER="${USER:-$(id -un)}"
    export HOST_UID="${HOST_UID:-$(id -u)}"
    export HOST_GID="${HOST_GID:-$(id -g)}"
    export HOST_HOME="${HOME:-$(getent passwd "$HOST_USER" | cut -d: -f6)}"
}

init_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
    fi
    
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" << 'EOF'
default_image: localhost/opencode-toolbox:latest
engine: podman

defaults:
  mount_ssh: false
  mount_gitconfig: true
  mount_docker: false
  mount_display: true
  home_mode: isolated

global_env:
  EDITOR: vim
  TZ: Asia/Shanghai
EOF
    fi
}

parse_config() {
    local key="$1"
    local default="${2:-}"
    
    if [[ -f "$CONFIG_FILE" ]]; then
        grep -E "^${key}:" "$CONFIG_FILE" 2>/dev/null | sed "s/^${key}:\s*//" | tr -d '"' || echo "$default"
    else
        echo "$default"
    fi
}

build_image() {
    log_info "构建 OpenCode toolbox 镜像..."
    
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    
    if [[ ! -f "$script_dir/Containerfile" ]]; then
        log_error "未找到 Containerfile"
        exit 1
    fi
    
    "$CONTAINER_ENGINE" build \
        -t "$TOOLBOX_IMAGE" \
        -f "$script_dir/Containerfile" \
        "$script_dir"
    
    log_success "镜像构建成功: $TOOLBOX_IMAGE"
}

generate_mount_args() {
    get_user_info
    
    local project_path="${1:-}"
    local mount_args=()
    
    mkdir -p "${HOST_HOME}/.cache/opencode-toolbox"
    
    mount_args+=(--volume /etc/localtime:/etc/localtime:ro)
    mount_args+=(--volume /tmp:/tmp)
    mount_args+=(--volume "${HOST_HOME}/.cache/opencode-toolbox:/tmp/toolbox-cache")
    
    local mount_display
    mount_display=$(parse_config "mount_display" "true")
    if [[ "$mount_display" == "true" ]]; then
        [[ -d /tmp/.X11-unix ]] && mount_args+=(--volume /tmp/.X11-unix:/tmp/.X11-unix:ro)
        mount_args+=(--env "DISPLAY=${DISPLAY:-:0}")
        mount_args+=(--env "WAYLAND_DISPLAY=${WAYLAND_DISPLAY:-}")
    fi
    
    local mount_ssh
    mount_ssh=$(parse_config "mount_ssh" "false")
    if [[ "$mount_ssh" == "true" && -d "${HOST_HOME}/.ssh" ]]; then
        mount_args+=(--volume "${HOST_HOME}/.ssh:${HOST_HOME}/.ssh:ro")
        mount_args+=(--env "SSH_AUTH_SOCK=${SSH_AUTH_SOCK:-}")
        [[ -S "${SSH_AUTH_SOCK:-}" ]] && mount_args+=(--volume "${SSH_AUTH_SOCK}:${SSH_AUTH_SOCK}:ro")
    fi
    
    local mount_git
    mount_git=$(parse_config "mount_gitconfig" "true")
    if [[ "$mount_git" == "true" ]]; then
        [[ -f "${HOST_HOME}/.gitconfig" ]] && mount_args+=(--volume "${HOST_HOME}/.gitconfig:${HOST_HOME}/.gitconfig:ro")
        [[ -f "${HOST_HOME}/.git-credentials" ]] && mount_args+=(--volume "${HOST_HOME}/.git-credentials:${HOST_HOME}/.git-credentials:ro")
        [[ -d "${HOST_HOME}/.git-hooks" ]] && mount_args+=(--volume "${HOST_HOME}/.git-hooks:${HOST_HOME}/.git-hooks:ro")
    fi
    
    local mount_docker
    mount_docker=$(parse_config "mount_docker" "false")
    if [[ "$mount_docker" == "true" ]]; then
        [[ -S /var/run/docker.sock ]] && mount_args+=(--volume /var/run/docker.sock:/var/run/docker.sock:rw)
        [[ -S /run/podman/podman.sock ]] && mount_args+=(--volume /run/podman/podman.sock:/run/podman/podman.sock:rw)
        [[ -S /run/user/$(id -u)/podman/podman.sock ]] && mount_args+=(--volume /run/user/$(id -u)/podman/podman.sock:/run/user/$(id -u)/podman/podman.sock:rw)
    fi
    
    if [[ -n "$project_path" && -d "$project_path" ]]; then
        local abs_path
        abs_path=$(cd "$project_path" && pwd)
        mount_args+=(--volume "${abs_path}:${abs_path}:rw")
        mount_args+=(--workdir "$abs_path")
    fi
    
    printf '%s\n' "${mount_args[@]}"
}

create_toolbox() {
    local input_name="${1:-}"
    local project_path="${2:-}"
    
    # 规范化项目名称
    local project_name
    project_name=$(normalize_project_name "$input_name")
    
    # 如果提供了第二个参数作为路径
    if [[ -n "$input_name" && -z "$project_path" && -d "$input_name" ]]; then
        # 用户只提供了一个参数，且它是目录
        project_path="$input_name"
        project_name=$(normalize_project_name "$input_name")
    elif [[ -z "$project_path" ]]; then
        # 没有提供路径，使用当前目录
        project_path="$(pwd)"
    fi
    
    local container_name
    container_name=$(generate_container_name "$project_name")
    
    log_info "创建 OpenCode toolbox: $container_name"
    log_info "项目路径: $project_path"
    log_info "项目名称: $project_name"
    
    if "$CONTAINER_ENGINE" ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_warn "容器 '$container_name' 已存在"
        read -p "删除并重新创建? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            "$CONTAINER_ENGINE" rm -f "$container_name" 2>/dev/null || true
        else
            log_info "使用现有容器"
            return 0
        fi
    fi
    
    get_user_info
    
    if ! "$CONTAINER_ENGINE" images --format '{{.Repository}}:{{.Tag}}' | grep -q "^${TOOLBOX_IMAGE}$"; then
        build_image
    fi
    
    local mount_args
    mount_args=$(generate_mount_args "$project_path")
    
    local toolbox_home="${HOST_HOME}/.local/share/opencode-toolbox/${project_name}"
    mkdir -p "$toolbox_home"
    
    local engine_args=()
    if [[ "$CONTAINER_ENGINE" == "podman" ]]; then
        engine_args+=(--userns=keep-id --hostname="toolbox-${project_name}")
    else
        engine_args+=(--hostname="toolbox-${project_name}")
    fi
    
    local run_args=(
        --name "$container_name"
        --detach
        --interactive
        --tty
        --env "USER=${HOST_USER}"
        --env "HOST_USER=${HOST_USER}"
        --env "HOST_UID=${HOST_UID}"
        --env "HOST_GID=${HOST_GID}"
        --env "HOME=${toolbox_home}"
        --env "TOOLBOX_HOME=${toolbox_home}"
        --env "PROJECT_PATH=${project_path}"
        --volume "${toolbox_home}:${toolbox_home}:rw"
        --env "EDITOR=$(parse_config "EDITOR" "vim")"
        --env "TZ=$(parse_config "TZ" "Asia/Shanghai")"
        --entrypoint /bin/bash
        --network bridge
    )
    
    while IFS= read -r line; do
        [[ -n "$line" ]] && run_args+=("$line")
    done <<< "$mount_args"
    
    "$CONTAINER_ENGINE" run "${engine_args[@]}" "${run_args[@]}" "$TOOLBOX_IMAGE" -c "sleep infinity"
    
    setup_container_user "$container_name" "$toolbox_home"
    
    "$CONTAINER_ENGINE" exec "$container_name" sh -c "echo 'opencode-toolbox' > /run/.toolboxenv" 2>/dev/null || true
    
    log_success "Toolbox 创建成功: $container_name"
    log_info "进入: opencode-toolbox enter $project_name"
    log_info "隔离 home 目录: $toolbox_home"
}

setup_container_user() {
    local container_name="$1"
    local toolbox_home="$2"
    
    log_info "配置容器用户..."
    
    "$CONTAINER_ENGINE" exec "$container_name" sh -c "
        getent group ${HOST_GID} >/dev/null 2>&1 || groupadd -g ${HOST_GID} ${HOST_USER}
        id -u ${HOST_USER} >/dev/null 2>&1 || useradd -m -u ${HOST_UID} -g ${HOST_GID} -s /bin/bash ${HOST_USER}
        usermod -aG sudo ${HOST_USER} 2>/dev/null || usermod -aG wheel ${HOST_USER} 2>/dev/null || true
        echo '%sudo ALL=(ALL) NOPASSWD: ALL' > /etc/sudoers.d/toolbox
        chmod 440 /etc/sudoers.d/toolbox
        mkdir -p ${toolbox_home}
        chown -R ${HOST_UID}:${HOST_GID} ${toolbox_home}
    " 2>/dev/null || true
    
    "$CONTAINER_ENGINE" exec "$container_name" sh -c "
        su - ${HOST_USER} -c 'npm config set prefix ~/.npm-global 2>/dev/null || true'
        su - ${HOST_USER} -c 'export PATH=\"\$HOME/.npm-global/bin:\$PATH\" && which opencode || npm install -g opencode-ai' 2>/dev/null || true
    " 2>/dev/null || log_warn "opencode 安装可能失败，进入容器后手动安装"
}

enter_toolbox() {
    local input_name="${1:-}"
    
    if [[ -z "$input_name" ]]; then
        log_info "可用的 toolbox:"
        list_toolboxes
        echo
        read -p "输入要进入的 toolbox 名称: " input_name
    fi
    
    local project_name
    project_name=$(normalize_project_name "$input_name")
    
    local container_name
    container_name=$(generate_container_name "$project_name")
    
    if ! "$CONTAINER_ENGINE" ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_warn "容器 '$container_name' 不存在"
        read -p "现在创建? [Y/n] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            create_toolbox "$input_name"
        else
            exit 1
        fi
    fi
    
    if ! "$CONTAINER_ENGINE" ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_info "启动容器 $container_name..."
        "$CONTAINER_ENGINE" start "$container_name" > /dev/null
    fi
    
    get_user_info
    local toolbox_home="${HOST_HOME}/.local/share/opencode-toolbox/${project_name}"
    local project_path
    project_path=$("$CONTAINER_ENGINE" inspect "$container_name" --format '{{range .Mounts}}{{if eq .Destination "'$(pwd)'"}}{{.Source}}{{end}}{{end}}' 2>/dev/null) || true
    
    log_info "进入 OpenCode toolbox: $container_name"
    echo -e "${GREEN}⬢${NC} Podman 模式 - Git 配置已挂载"
    echo
    
    exec "$CONTAINER_ENGINE" exec -it \
        --user "$HOST_UID:$HOST_GID" \
        --env "HOME=$toolbox_home" \
        --env "TOOLBOX_HOME=$toolbox_home" \
        "$container_name" \
        /bin/bash -c "
            export PATH=\"${toolbox_home}/.npm-global/bin:${toolbox_home}/.local/bin:/usr/local/bin:/usr/bin:/bin\"
            export PS1='\\[\\033[0;32m\\]⬢[\\033[0m\\] \\[\\033[1;34m\\]\\u@toolbox\\[\\033[0m\\]:\\[\\033[0;36m\\]\\w\\[\\033[0m\\]\\$ '
            cd '${project_path:-$toolbox_home}' 2>/dev/null || cd '$toolbox_home'
            
            echo -e '${GREEN}OpenCode Toolbox Ready!${NC}'
            echo -e '${BLUE}隔离 home: ${toolbox_home}${NC}'
            echo -e '${BLUE}Git 配置: 已挂载${NC}'
            echo -e '${BLUE}运行 opencode 启动 AI 编程助手${NC}'
            echo ''
            
            exec /bin/bash --rcfile <(echo '
                export PATH=\"${toolbox_home}/.npm-global/bin:${toolbox_home}/.local/bin:/usr/local/bin:/usr/bin:/bin\"
                export PS1=\"\\[\\033[0;32m\\]⬢[\\033[0m\\] \\[\\033[1;34m\\]\\u@toolbox\\[\\033[0m\\]:\\[\\033[0;36m\\]\\w\\[\\033[0m\\]\\$ \"
                alias ll=\"ls -la\"
            ')
        "
}

run_in_toolbox() {
    local input_name="${1:-}"
    shift || true
    
    if [[ -z "$input_name" || "$input_name" == --* ]]; then
        log_error "需要指定项目名称"
        echo "用法: opencode-toolbox run <project-name> <命令>"
        exit 1
    fi
    
    local project_name
    project_name=$(normalize_project_name "$input_name")
    
    local container_name
    container_name=$(generate_container_name "$project_name")
    
    if ! "$CONTAINER_ENGINE" ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
        if "$CONTAINER_ENGINE" ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
            log_info "启动容器..."
            "$CONTAINER_ENGINE" start "$container_name" > /dev/null
        else
            log_error "容器 '$container_name' 不存在"
            exit 1
        fi
    fi
    
    get_user_info
    local toolbox_home="${HOST_HOME}/.local/share/opencode-toolbox/${project_name}"
    
    if [[ $# -eq 0 ]]; then
        set -- opencode
    fi
    
    log_info "在 $container_name 中运行: $*"
    "$CONTAINER_ENGINE" exec \
        --user "$HOST_UID:$HOST_GID" \
        --env "HOME=$toolbox_home" \
        --env "PATH=${toolbox_home}/.npm-global/bin:/usr/local/bin:/usr/bin:/bin" \
        "$container_name" \
        /bin/bash -c "cd '\$(pwd)' 2>/dev/null || true; exec $*"
}

list_toolboxes() {
    get_user_info
    
    log_info "OpenCode Toolbox 容器:"
    echo
    
    local containers
    containers=$("$CONTAINER_ENGINE" ps -a --filter "name=toolbox-opencode-" --format "{{.Names}}|{{.Status}}|{{.Image}}" 2>/dev/null)
    
    if [[ -n "$containers" ]]; then
        printf "%-30s %-20s %s\n" "名称" "状态" "镜像"
        echo "$(printf '%0.s-' {1..80})"
        
        while IFS='|' read -r name status image; do
            local display_name="${name#toolbox-opencode-}"
            printf "%-30s %-20s %s\n" "$display_name" "$status" "$image"
        done <<< "$containers"
    else
        echo "  没有找到 toolbox 容器"
        echo "  创建一个: opencode-toolbox create <项目名称>"
    fi
    echo
    
    local toolbox_base="${HOST_HOME}/.local/share/opencode-toolbox"
    if [[ -d "$toolbox_base" ]]; then
        log_info "隔离 home 目录使用情况:"
        du -sh "${toolbox_base}"/* 2>/dev/null | while read -r size path; do
            local name=$(basename "$path")
            echo "  $name: $size"
        done
    fi
}

remove_toolbox() {
    get_user_info
    
    local input_name="${1:-}"
    
    if [[ -z "$input_name" ]]; then
        log_error "需要指定项目名称"
        echo "用法: opencode-toolbox rm <项目名称>"
        exit 1
    fi
    
    local project_name
    project_name=$(normalize_project_name "$input_name")
    
    local container_name
    container_name=$(generate_container_name "$project_name")
    
    log_warn "删除 toolbox: $project_name"
    
    if "$CONTAINER_ENGINE" ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        "$CONTAINER_ENGINE" rm -f "$container_name" 2>/dev/null
        log_success "容器已删除: $container_name"
    fi
    
    local toolbox_home="${HOST_HOME}/.local/share/opencode-toolbox/${project_name}"
    if [[ -d "$toolbox_home" ]]; then
        read -p "是否删除隔离 home 目录 (${toolbox_home})? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            rm -rf "$toolbox_home"
            log_success "隔离 home 目录已删除"
        fi
    fi
}

show_help() {
    cat << 'EOF'
OpenCode Toolbox - 带隔离的容器化开发环境

用法:
  opencode-toolbox create [名称|路径]    创建新的 toolbox
  opencode-toolbox enter [名称|路径]     进入 toolbox
  opencode-toolbox run <名称> [命令]     在 toolbox 中运行命令
  opencode-toolbox list                  列出所有 toolbox
  opencode-toolbox rm <名称>             删除 toolbox
  opencode-toolbox build                 构建 toolbox 镜像

示例:
  # 使用当前目录名创建
  opencode-toolbox create

  # 指定名称创建
  opencode-toolbox create myproject

  # 使用 . 创建（自动获取当前目录名）
  opencode-toolbox enter .

  # 进入 toolbox
  opencode-toolbox enter myproject

容器名称格式: toolbox-opencode-<项目名>

EOF
}

main() {
    local cmd="${1:-help}"
    shift || true
    
    init_config
    
    case "$cmd" in
        create)
            create_toolbox "$@"
            ;;
        enter)
            enter_toolbox "$@"
            ;;
        run)
            run_in_toolbox "$@"
            ;;
        list|ls)
            list_toolboxes
            ;;
        rm|remove)
            remove_toolbox "$@"
            ;;
        build)
            build_image
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            log_error "未知命令: $cmd"
            show_help
            exit 1
            ;;
    esac
}

main "$@"
